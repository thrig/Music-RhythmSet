#!/usr/bin/env perl
#
# beatinator - generates three voices that vary their rhythmic patterns
# over time. MIDI output and a text log of the changes are produced

use 5.24.0;
use warnings;

use Music::RhythmSet;
use Music::RhythmSet::Util
  qw(beatstring compare_onsets filter_pattern);

my $filename = shift
  // die "Usage: $0 midi-file [measure-count]\n";
my $measures = shift // 64;
# all voices use the same number of beats per measure (this need not
# be true)
my $BPM  = 16;
my $rest = [ (0) x $BPM ];

# the main voice changes less often than the other voices (every 16
# measures), always uses five onsets per measure, and has less variance
# (300 trials) in possible rhythms
sub mainpattern { filter_pattern(5, $BPM, 300), 16 }

# secondary voices
sub nextpattern {
    my ($self, %param) = @_;
    my $id     = $self->id;
    my $voices = $param{set}->voices;
    my ($new, $onsets);
  CHOICE: {
        # varied numbers of beats, increased variance (only 100 trials)
        $new = filter_pattern(3 + int rand 5, $BPM, 100);
        for my $n (0 .. $id - 1) {
            # NOTE if the percentage is too low or there are too many
            # voices this can soft-lock the loop; in such a case there
            # would need to be a way to relax this restriction after
            # some number of loops, or to make the restriction vary
            # depending on the voice. OTOH you might want more overlap
            # between the voices...
            redo CHOICE
              if compare_onsets($new, $voices->[$n]->pattern) >= 0.4;
        }
    }
    # eight measure TTL
    return $new, 8;
}

# the secondary voices start after 4 or 8 measures of silence
my $set = Music::RhythmSet->new->add(
    { next => \&mainpattern },
    { next => \&nextpattern, pattern => $rest, ttl => 4 },
    { next => \&nextpattern, pattern => $rest, ttl => 8 },
);

$set->advance($measures);

# different notes for the different voices so they are easier to tell
# apart (they might instead use the same note and then the MIDI player
# could make them distinct by changing the instrument, etc)
$set->to_midi(
    $measures,
    chan    => 9,    # drum
    sustain => 0,
    track   => [ { note => 60 }, { note => 67 }, { note => 68 } ]
)->write_to_file($filename);

# show what the patterns are in each measure where a pattern changes
# (there are also text_event in the MIDI to help locate the rhythms
# should this script by accident produce something good)
$set->changes(
    divisor => $BPM,
    max     => $measures,
    header  => sub { say '# measure ' . $_[0] },
    voice   => sub {
        my ($mm, $id, $bp, $bs, $new, $repeat) = @_;
        # 'n' if there was a pattern change event for this voice, 'r' if
        # that change event did not actually change the pattern
        # (probably uncommon in this script)
        say join "\t", $id, $bs,
          ($new ? 'n' : '') . ($repeat ? 'r' : '');
    }
);
