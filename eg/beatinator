#!/usr/bin/env perl
#
# beatinator - generates three voices that vary their rhythmic patterns
# over time. MIDI output and a text log of the changes are produced
#
#   $ perl beatinator foo.midi
#   ...
#   $ timidity -A90a --trace-text-meta foo.midi

use 5.24.0;
use warnings;
use Music::RhythmSet;
use Music::RhythmSet::Util qw(filter_pattern);

my $filename = shift // die "Usage: $0 midi-file [measure-count]\n";
my $measures = shift // 64;
# all voices use the same number of beats per measure (this need not be
# true but would make the "measures" harder to line up between voices)
my $BPM  = 16;
my $rest = [ (0) x $BPM ];

# each voice has a consistent (but different) number of onsets per
# measure. those with more onsets are given more trials to lower
# the rhythmic variance (see eg/variance)
my @onsets = ([ 3, 100 ], [ 7, 600 ]);

sub voice0 {
    state $i = 0;
    # mixup which of the two other voices is more active every so often
    if (++$i == 2) { $i = 0; @onsets = reverse @onsets }
    # if you know what rhythms you want to use it would be simpler to
    # put them into a structure and use that somehow. filter_pattern
    # finds patterns that best fit a ranking system; this may not result
    # in usable rhythms
    filter_pattern(5, $BPM, 400), 16;
}

sub voice1 {
    # one time fixup of when the rhythm changes for this voice
    state $i = 0;
    my $ttl = $i++ ? 16 : 8;
    filter_pattern($onsets[0][0], $BPM, $onsets[0][1]), $ttl;
}

sub voice2 {
    filter_pattern($onsets[1][0], $BPM, $onsets[1][1]), 16;
}

# delayed onsets for two of the voices
my $set = Music::RhythmSet->new->add(
    { next => \&voice0 },
    { next => \&voice1, pattern => $rest, ttl => 8 },
    { next => \&voice2, pattern => $rest, ttl => 16 },
);

# generate the replay log
$set->advance($measures);

# different notes for the different voices so they are easier to tell
# apart (they might instead use the same note and then the MIDI player
# could make them distinct by changing the instrument, etc)
$set->to_midi(
    chan    => 9,                                                   # drum
    sustain => 0,
    track   => [ { note => 60 }, { note => 67 }, { note => 68 } ]
)->write_to_file($filename);

# show what the patterns are in each measure where a pattern changes
# (there are also text_event in the MIDI to help locate the rhythms
# should this script by accident produce something good)
$set->changes(
    header  => sub { say '# measure ' . $_[0] },
    voice   => sub {
        my ($mm, $id, $bp, $bs, $new, $repeat) = @_;
        # 'n' if there was a pattern change event for this voice, 'r' if
        # that change event did not actually change the pattern
        # (uncommon in this script)
        say join "\t", $id, $bs, ($new ? 'n' : '') . ($repeat ? 'r' : '');
    }
);
